---
description: Include when adding new ESI functionality to the rust backend
alwaysApply: false
---

# ESI Client System

## Overview

The ESI (EVE Swagger Interface) client is auto-generated from the EVE Online OpenAPI schema. It provides type-safe access to the EVE Online API.

## Location

- **Module**: `src-tauri/src/esi/`
- **Files**:
  - `mod.rs` - Module exports (`BASE_URL`, client types, cached utilities)
  - `client.rs` - Generated client code (do not edit manually)
  - `types.rs` - Generated type definitions (do not edit manually)
  - `cached.rs` - Caching and rate limit tracking utilities
  - `openapi.json` - Cached OpenAPI schema

## Regenerating the Client

Run the generation script:

```bash
./scripts/generate-esi.sh
```

This script:

1. Downloads the latest OpenAPI schema
2. Generates `types.rs` and `client.rs` using `oas3-gen`
3. Adds necessary imports and suppresses unused code warnings

**Important**: The generated files are not checked into version control. They are generated at build time. Only regenerate manually when the ESI API schema changes.

## Usage Pattern

### Base URL

```rust
use esi::BASE_URL;

let url = BASE_URL.parse::<reqwest::Url>()?
    .join("characters/12345/skillqueue")?;
```

### Request Types

Import request types from the `esi` module:

```rust
use esi::GetCharactersCharacterIdSkillqueueRequest;

let mut request = GetCharactersCharacterIdSkillqueueRequest {
    character_id: 12345,
    x_compatibility_date: chrono::NaiveDate::from_ymd_opt(2020, 1, 1).unwrap(),
    ..Default::default()
};
```

### Response Types

Response types are also available from the `esi` module:

```rust
use esi::CharactersCharacterIdSkillqueueGet;

let response: CharactersCharacterIdSkillqueueGet = client.get(url).send().await?.json().await?;
```

## Authentication

Create an authenticated HTTP client using the helper function:

```rust
fn create_authenticated_client(access_token: &str) -> Result<reqwest::Client> {
    let mut headers = HeaderMap::new();
    let auth_value = HeaderValue::from_str(&format!("Bearer {}", access_token))?;
    headers.insert(AUTHORIZATION, auth_value);
    reqwest::Client::builder()
        .default_headers(headers)
        .build()
}
```

The access token comes from the `tokens` table in the database. See `src-tauri/src/lib.rs` for the implementation.

## Caching and Rate Limit Tracking

ESI responses should always use the unified caching and rate limit tracking system via `esi::fetch_cached()`. This function handles both caching and rate limit tracking automatically.

### Rate Limit Tracking

Rate limits are tracked per character using `esi::RateLimitStore`, which is managed as Tauri state:

- **Type**: `esi::RateLimitStore` = `Arc<RwLock<HashMap<i64, HashMap<String, RateLimitInfo>>>>`
- **Structure**: Character ID → Rate limit group → Rate limit info
- **Info Fields**: `group`, `limit`, `remaining`, `window_minutes`, `updated_at`

Rate limit information is extracted from ESI response headers:

- `x-ratelimit-group` - Rate limit group name
- `x-ratelimit-limit` - Limit format: `{limit}/{window}m` (e.g., `100/60m`)
- `x-ratelimit-remaining` - Remaining requests in current window

### Primary Request Function

Use `esi::fetch_cached()` for all ESI API requests:

```rust
use esi::{fetch_cached, RateLimitStore};

async fn get_skill_queue(
    pool: &db::Pool,
    client: &reqwest::Client,
    character_id: i64,
    rate_limits: &RateLimitStore,
) -> Result<Option<SkillQueueResponse>> {
    let endpoint_path = format!("characters/{}/skillqueue", character_id);
    let cache_key = cache::build_cache_key(&endpoint_path, character_id);

    fetch_cached::<SkillQueueResponse>(
        pool,
        client,
        &endpoint_path,
        &cache_key,
        rate_limits,
        character_id,
    ).await
}
```

This function:

1. Checks cache for existing response
2. Uses ETag for conditional requests if cached
3. Tracks rate limits from response headers
4. Stores response in cache with expiration
5. Returns cached data on 304 Not Modified

### Cache Helpers

Located in `src-tauri/src/cache/mod.rs`:

- `cache::build_cache_key(endpoint, character_id)` - Build cache key
- `cache::get_cached_response(pool, cache_key)` - Get cached response (returns body and ETag)
- `cache::set_cached_response(pool, cache_key, etag, expires_at, response_body)` - Store response
- `cache::extract_etag(headers)` - Extract ETag from response headers
- `cache::extract_expires(headers)` - Extract expiration time from headers
- `cache::clear_character_cache(pool, character_id)` - Clear all cache entries for a character

### Rate Limit Access

To retrieve current rate limit information, use the `get_rate_limits` Tauri command from the frontend, or access the `RateLimitStore` state in Rust commands:

```rust
#[tauri::command]
async fn get_rate_limits(
    rate_limits: State<'_, esi::RateLimitStore>,
) -> Result<Vec<CharacterRateLimits>, String> {
    let store = rate_limits.read().await;
    // Access rate limit data
}
```

## Cache Table

The `esi_cache` table stores:

- `cache_key`: Unique identifier (e.g., `"characters/12345/skillqueue"`)
- `etag`: ETag from response headers (for conditional requests)
- `expires_at`: Unix timestamp when cache expires
- `response_body`: JSON response body

## Best Practices

- Always use `esi::fetch_cached()` for ESI requests to get caching and rate limit tracking automatically
- Pass `rate_limits: &esi::RateLimitStore` to all ESI fetching functions
- Access rate limit information via `get_rate_limits` Tauri command when needed
- Include ETag in requests when available (`If-None-Match` header) - handled automatically by `fetch_cached()`
- Handle 304 Not Modified responses (when ETag matches) - handled automatically by `fetch_cached()`
- Respect cache expiration times from response headers - handled automatically
- Use `x_compatibility_date` in requests for API versioning - included automatically by `fetch_cached()`
- Rate limits are tracked per character automatically
- Clear character cache when forcing refresh (e.g., `cache::clear_character_cache()`)
