---
alwaysApply: true
---

# Development Guidelines

## Package Management

**Always use pnpm**, never npm or yarn. The project uses `pnpm-lock.yaml` for dependency locking.

```bash
pnpm install          # Install dependencies
pnpm add <package>    # Add dependency
pnpm remove <package> # Remove dependency
```

## UI Components

**Always use the shadcn CLI** to add components. Never manually create shadcn component files.

```bash
pnpm dlx shadcn@latest add button
pnpm dlx shadcn@latest add dialog
```

Components are added to `src/components/ui/` automatically. The configuration is in `components.json`.

## Database

- **Use sqlx** with compile-time query checking
- **Use transactions** for multi-step operations
- **Use `anyhow::Result`** for error propagation in Rust
- **Use `?` operator** for error handling
- **Prefer type-safe queries** with `query_as!` or `query_as::<_, Type>`

## ESI Requests

- **Always use `esi::fetch_cached()`** for ESI API requests (handles caching and rate limit tracking)
- **Pass `rate_limits: &esi::RateLimitStore`** to all ESI fetching functions
- **Include ETag** in requests when available (handled automatically by `fetch_cached()`)
- **Handle 304 Not Modified** responses (handled automatically by `fetch_cached()`)
- **Respect rate limits** (tracked automatically per character)

See the `esi-client` rule for detailed caching patterns and examples.

## Frontend Data Fetching

- **Always use React Query** (`@tanstack/react-query`) for data fetching
- **Never use `fetch` or `axios`** directly for Tauri commands
- **Use generated command functions** from `@/generated/commands` instead of calling `invoke()` directly
- **Use custom hooks** in `src/hooks/tauri/` to wrap Tauri commands
- **Invalidate queries** after mutations to refresh data
- **TypeScript types are auto-generated** - use `@/generated/types` instead of manually defining types

See the `frontend-patterns` rule for detailed patterns and examples.

## Tauri Commands

- **Return `Result<T, String>`** for error handling
- **Use `State<'_, db::Pool>`** to access database
- **Include `rate_limits: State<'_, esi::RateLimitStore>`** for commands that make ESI API requests
- **Use `async`** for all commands
- **Convert errors** with `.map_err(|e| format!("Error: {}", e))`
- **Emit events** when state changes that frontend should know about
- **TypeScript bindings are auto-generated** - types and command functions are created during build

See the `tauri-commands` rule for detailed patterns and examples.

## Error Handling

- **Rust**: Use `anyhow::Result` internally, convert to `Result<T, String>` for Tauri commands
- **TypeScript**: Handle errors from React Query (`error` state)
- **User-facing errors**: Provide clear, actionable error messages

## Code Style

- **Rust**: Follow standard Rust conventions (snake_case, etc.)
- **TypeScript**: Use TypeScript strict mode, prefer interfaces over types for objects
- **React**: Use functional components, hooks, TypeScript
- **Comments**: Only add comments for complex logic, not obvious code

## Testing

- Test database operations with actual SQLite database
- Test ESI integration with mocked responses or test tokens
- Test frontend components with React Query's testing utilities

## Git Workflow

- **Don't commit** generated files unnecessarily (ESI client files are generated at build time)
- **Do commit** migration files
- **Do commit** rule files (`.cursor/rules/`)

## Environment Variables

- **Never commit** `.env` files
- **Document** required environment variables in rules
- **Use** environment variables for sensitive data (client IDs, etc.)

## Best Practices Summary

1. Use pnpm for package management
2. Use shadcn CLI for components
3. Use sqlx for type-safe database queries
4. Use React Query for all data fetching
5. Use generated command functions from `@/generated/commands` instead of `invoke()` directly
6. Use `esi::fetch_cached()` for all ESI requests (handles caching and rate limits)
7. Return `Result<T, String>` from Tauri commands
8. Include `rate_limits` state for commands making ESI requests
9. Follow existing patterns when adding new features
10. Keep components and functions focused and small
11. Use auto-generated TypeScript types from `@/generated/types`
12. Handle errors gracefully with clear messages
